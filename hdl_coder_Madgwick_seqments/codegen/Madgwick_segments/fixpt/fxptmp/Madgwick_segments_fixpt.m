%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
%       Generated by MATLAB 8.3, MATLAB Coder 2.6 and HDL Coder 3.4        %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#codegen
%=====================================================================================================
% Madgwick.m is a direct Matlab port of MadgwickAHRS.c
%=====================================================================================================
%
% sampleFreq	= 512.0;		% sample frequency in Hz
% sampleTime    = 1/sampleFreq;
% betaDef		= 0.1;		% 2 * proportional gain
% beta = betaDef;     % 2 * proportional gain (Kp)
%
% % quaternion of sensor frame relative to auxiliary frame
% q0 = 1.0;
% q1 = 0.0;
% q2 = 0.0;
% q3 = 0.0;
%
function [q0,q1,q2,q3] = Madgwick_segments_fixpt(q0_1,q1_1,q2_1,q3_1,gx,gy,gz,ax_1,ay_1,az_1,mx_1,my_1,mz_1)

fm = fimath('RoundingMethod', 'Floor', 'OverflowAction', 'Wrap', 'ProductMode', 'FullPrecision', 'MaxProductWordLength', 128, 'SumMode', 'FullPrecision', 'MaxSumWordLength', 128);

ax = fi(ax_1, 1, 24, 12, fm);
ay = fi(ay_1, 1, 24, 12, fm);
az = fi(az_1, 1, 24, 12, fm);
mx = fi(mx_1, 1, 24, 12, fm);
my = fi(my_1, 1, 24, 12, fm);
mz = fi(mz_1, 1, 24, 12, fm);
q0 = fi(q0_1, 1, 24, 12, fm);
q1 = fi(q1_1, 1, 24, 12, fm);
q2 = fi(q2_1, 1, 24, 12, fm);
q3 = fi(q3_1, 1, 24, 12, fm);

sampleFreq = fi(512.0, 0, 10, 0, fm);
% sample frequency in Hz
sampleTime = fi(fi_div(fi(1, 0, 1, 0, fm), sampleFreq), 0, 24, 12, fm);
betaDef = fi(0.1, 0, 24, 12, fm);  % 2 * proportional gain
beta = fi(betaDef, 0, 24, 12, fm);  % 2 * proportional gain (Kp)
[fmo_1,fmo_2,fmo_3,fmo_4] = f10_Madgwick_qDot( q0, q1, q2, q3, gx, gy, gz );
qDot1 = fi(fmo_1, 1, 24, 12, fm);
qDot2 = fi(fmo_2, 1, 24, 12, fm);
qDot3 = fi(fmo_3, 1, 24, 12, fm);
qDot4 = fi(fmo_4, 1, 24, 12, fm);
[fmo_5,fmo_6,fmo_7,fmo_8] = f14_Madgwick_normalize( ax, ay, az, fi(0, 0, 1, 0, fm) );
ax = fi(fmo_5, 1, 24, 12, fm);
ay = fi(fmo_6, 1, 24, 12, fm);
az = fi(fmo_7, 1, 24, 12, fm);
unused1 = fi(fmo_8, 0, 1, 0, fm);
[fmo_9,fmo_10,fmo_11,fmo_12] = f14_Madgwick_normalize( mx, my, mz, fi(0, 0, 1, 0, fm) );
mx = fi(fmo_9, 1, 24, 12, fm);
my = fi(fmo_10, 1, 24, 12, fm);
mz = fi(fmo_11, 1, 24, 12, fm);
unused1 = fi(fmo_12, 0, 1, 0, fm);
[fmo_13,fmo_14,fmo_15,fmo_16] = f15_Madgwick_correction( q0, q1, q2, q3, ax, ay, az, mx, my, mz );
s0 = fi(fmo_13, 1, 24, 12, fm);
s1 = fi(fmo_14, 1, 24, 12, fm);
s2 = fi(fmo_15, 1, 24, 12, fm);
s3 = fi(fmo_16, 1, 24, 12, fm);
[fmo_17,fmo_18,fmo_19,fmo_20] = f14_Madgwick_normalize( s0, s1, s2, s3 );
s0 = fi(fmo_17, 1, 24, 12, fm);
s1 = fi(fmo_18, 1, 24, 12, fm);
s2 = fi(fmo_19, 1, 24, 12, fm);
s3 = fi(fmo_20, 1, 24, 12, fm);
[fmo_21,fmo_22,fmo_23,fmo_24] = f16_Madgwick_update( q0, q1, q2, q3, qDot1, qDot2, qDot3, qDot4, s0, s1, s2, s3, beta, sampleTime );
q0 = fi(fmo_21, 1, 24, 12, fm);
q1 = fi(fmo_22, 1, 24, 12, fm);
q2 = fi(fmo_23, 1, 24, 12, fm);
q3 = fi(fmo_24, 1, 24, 12, fm);
[fmo_25,fmo_26,fmo_27,fmo_28] = f14_Madgwick_normalize( q0, q1, q2, q3 );
q0 = fi(fmo_25, 1, 24, 12, fm);
q1 = fi(fmo_26, 1, 24, 12, fm);
q2 = fi(fmo_27, 1, 24, 12, fm);
q3 = fi(fmo_28, 1, 24, 12, fm);
end
function [qDot1,qDot2,qDot3,qDot4] = f10_Madgwick_qDot(q0,q1,q2,q3,gx,gy,gz)

fm = fimath('RoundingMethod', 'Floor', 'OverflowAction', 'Wrap', 'ProductMode', 'FullPrecision', 'MaxProductWordLength', 128, 'SumMode', 'FullPrecision', 'MaxSumWordLength', 128);
% Rate of change of quaternion from gyroscope
qDot1 = fi(fi(0.5, 0, 24, 24, fm)*(fi_signed(fi_signed(fi_uminus(q1)*gx) - q2*gy) - q3*gz), 1, 24, 17, fm);
qDot2 = fi(fi(0.5, 0, 24, 24, fm)*(fi_signed(q0*gx + q2*gz) - q3*gy), 1, 24, 17, fm);
qDot3 = fi(fi(0.5, 0, 24, 24, fm)*(fi_signed(q0*gy) - q1*gz + q3*gx), 1, 24, 17, fm);
qDot4 = fi(fi(0.5, 0, 24, 24, fm)*(fi_signed(q0*gz + q1*gy) - q2*gx), 1, 24, 17, fm);
end
function [ax,ay,az,aw] = f14_Madgwick_normalize(ax_1,ay_1,az_1,aw_1)

fm = fimath('RoundingMethod', 'Floor', 'OverflowAction', 'Wrap', 'ProductMode', 'FullPrecision', 'MaxProductWordLength', 128, 'SumMode', 'FullPrecision', 'MaxSumWordLength', 128);

aw = fi(aw_1, 1, 24, 16, fm);
ax = fi(ax_1, 1, 24, 17, fm);
ay = fi(ay_1, 1, 24, 16, fm);
az = fi(az_1, 1, 24, 16, fm);

dotproduct = fi(ax*ax + ay*ay + az*az + aw*aw, 0, 24, 9, fm);
if dotproduct~=fi(0, 0, 1, 0, fm)
    recipNorm = fi(fi_div(fi(1, 0, 1, 0, fm), sqrt( dotproduct )), 0, 24, 21, fm);
    ax = fi(ax*recipNorm, 1, 24, 17, fm);
    ay = fi(ay*recipNorm, 1, 24, 16, fm);
    az = fi(az*recipNorm, 1, 24, 16, fm);
    aw = fi(aw*recipNorm, 1, 24, 16, fm);
end
end
function [s0,s1,s2,s3] = f15_Madgwick_correction(q0,q1,q2,q3,ax,ay,az,mx,my,mz)

fm = fimath('RoundingMethod', 'Floor', 'OverflowAction', 'Wrap', 'ProductMode', 'FullPrecision', 'MaxProductWordLength', 128, 'SumMode', 'FullPrecision', 'MaxSumWordLength', 128);
% Auxiliary variables to avoid repeated arithmetic
v2q0mx = fi(fi(2.0, 0, 2, 0, fm)*q0*mx, 1, 24, 22, fm);
v2q0my = fi(fi(2.0, 0, 2, 0, fm)*q0*my, 1, 24, 22, fm);
v2q0mz = fi(fi(2.0, 0, 2, 0, fm)*q0*mz, 1, 24, 22, fm);
v2q1mx = fi(fi(2.0, 0, 2, 0, fm)*q1*mx, 1, 24, 22, fm);
v2q0 = fi(fi(2.0, 0, 2, 0, fm)*q0, 0, 24, 23, fm);
v2q1 = fi(fi(2.0, 0, 2, 0, fm)*q1, 0, 24, 23, fm);
v2q2 = fi(fi(2.0, 0, 2, 0, fm)*q2, 0, 24, 23, fm);
v2q3 = fi(fi(2.0, 0, 2, 0, fm)*q3, 0, 24, 23, fm);
v2q0q2 = fi(fi(2.0, 0, 2, 0, fm)*q0*q2, 0, 24, 23, fm);
v2q2q3 = fi(fi(2.0, 0, 2, 0, fm)*q2*q3, 0, 24, 23, fm);
q0q0 = fi(q0*q0, 0, 24, 24, fm);
q0q1 = fi(q0*q1, 0, 24, 24, fm);
q0q2 = fi(q0*q2, 0, 24, 24, fm);
q0q3 = fi(q0*q3, 0, 24, 24, fm);
q1q1 = fi(q1*q1, 0, 24, 24, fm);
q1q2 = fi(q1*q2, 0, 24, 24, fm);
q1q3 = fi(q1*q3, 0, 24, 24, fm);
q2q2 = fi(q2*q2, 0, 24, 24, fm);
q2q3 = fi(q2*q3, 0, 24, 24, fm);
q3q3 = fi(q3*q3, 0, 24, 24, fm);
% Reference direction of Earth's magnetic field
hx = fi(fi_signed(fi_signed(fi_signed(mx*q0q0) - v2q0my*q3 + v2q0mz*q2 + mx*q1q1 + v2q1*my*q2 + v2q1*mz*q3) - mx*q2q2) - mx*q3q3, 1, 24, 21, fm);
hy = fi(fi_signed(fi_signed(fi_signed(v2q0mx*q3 + my*q0q0) - v2q0mz*q1 + v2q1mx*q2) - my*q1q1 + my*q2q2 + v2q2*mz*q3) - my*q3q3, 1, 24, 21, fm);
v2bx = fi(sqrt( hx*hx + hy*hy ), 0, 24, 22, fm);
v2bz = fi(fi_signed(fi_signed(fi_uminus(v2q0mx)*q2 + v2q0my*q1 + mz*q0q0 + v2q1mx*q3) - mz*q1q1 + v2q2*my*q3) - mz*q2q2 + mz*q3q3, 1, 24, 21, fm);
v4bx = fi(fi(2.0, 0, 2, 0, fm)*v2bx, 0, 24, 21, fm);
v4bz = fi(fi(2.0, 0, 2, 0, fm)*v2bz, 1, 24, 20, fm);
% Gradient decent algorithm corrective step
s0 = fi(fi_signed(fi_uminus(v2q2)*(fi_signed(fi_signed(fi(2.0, 0, 2, 0, fm)*q1q3) - v2q0q2) - ax) + v2q1*(fi_signed(fi(2.0, 0, 2, 0, fm)*q0q1 + v2q2q3) - ay)) - v2bz*q2*(fi_signed(v2bx*(fi_signed(fi_signed(fi(0.5, 0, 24, 24, fm)) - q2q2) - q3q3) + v2bz*(fi_signed(q1q3) - q0q2)) - mx) + (fi_uminus(v2bx)*q3 + v2bz*q1)*(fi_signed(v2bx*(fi_signed(q1q2) - q0q3) + v2bz*(q0q1 + q2q3)) - my) + v2bx*q2*(fi_signed(v2bx*(q0q2 + q1q3) + v2bz*(fi_signed(fi_signed(fi(0.5, 0, 24, 24, fm)) - q1q1) - q2q2)) - mz), 1, 24, 17, fm);
s1 = fi(fi_signed(v2q3*(fi_signed(fi_signed(fi(2.0, 0, 2, 0, fm)*q1q3) - v2q0q2) - ax) + v2q0*(fi_signed(fi(2.0, 0, 2, 0, fm)*q0q1 + v2q2q3) - ay)) - fi(4.0, 0, 3, 0, fm)*q1*(fi_signed(fi_signed(fi_signed(fi(1, 0, 1, 0, fm)) - fi(2.0, 0, 2, 0, fm)*q1q1) - fi(2.0, 0, 2, 0, fm)*q2q2) - az) + v2bz*q3*(fi_signed(v2bx*(fi_signed(fi_signed(fi(0.5, 0, 24, 24, fm)) - q2q2) - q3q3) + v2bz*(fi_signed(q1q3) - q0q2)) - mx) + (v2bx*q2 + v2bz*q0)*(fi_signed(v2bx*(fi_signed(q1q2) - q0q3) + v2bz*(q0q1 + q2q3)) - my) + (fi_signed(v2bx*q3) - v4bz*q1)*(fi_signed(v2bx*(q0q2 + q1q3) + v2bz*(fi_signed(fi_signed(fi(0.5, 0, 24, 24, fm)) - q1q1) - q2q2)) - mz), 1, 24, 16, fm);
s2 = fi(fi_signed(fi_uminus(v2q0)*(fi_signed(fi_signed(fi(2.0, 0, 2, 0, fm)*q1q3) - v2q0q2) - ax) + v2q3*(fi_signed(fi(2.0, 0, 2, 0, fm)*q0q1 + v2q2q3) - ay)) - fi(4.0, 0, 3, 0, fm)*q2*(fi_signed(fi_signed(fi_signed(fi(1, 0, 1, 0, fm)) - fi(2.0, 0, 2, 0, fm)*q1q1) - fi(2.0, 0, 2, 0, fm)*q2q2) - az) + (fi_signed(fi_uminus(v4bx)*q2) - v2bz*q0)*(fi_signed(v2bx*(fi_signed(fi_signed(fi(0.5, 0, 24, 24, fm)) - q2q2) - q3q3) + v2bz*(fi_signed(q1q3) - q0q2)) - mx) + (v2bx*q1 + v2bz*q3)*(fi_signed(v2bx*(fi_signed(q1q2) - q0q3) + v2bz*(q0q1 + q2q3)) - my) + (fi_signed(v2bx*q0) - v4bz*q2)*(fi_signed(v2bx*(q0q2 + q1q3) + v2bz*(fi_signed(fi_signed(fi(0.5, 0, 24, 24, fm)) - q1q1) - q2q2)) - mz), 1, 24, 16, fm);
s3 = fi(v2q1*(fi_signed(fi_signed(fi(2.0, 0, 2, 0, fm)*q1q3) - v2q0q2) - ax) + v2q2*(fi_signed(fi(2.0, 0, 2, 0, fm)*q0q1 + v2q2q3) - ay) + (fi_uminus(v4bx)*q3 + v2bz*q1)*(fi_signed(v2bx*(fi_signed(fi_signed(fi(0.5, 0, 24, 24, fm)) - q2q2) - q3q3) + v2bz*(fi_signed(q1q3) - q0q2)) - mx) + (fi_uminus(v2bx)*q0 + v2bz*q2)*(fi_signed(v2bx*(fi_signed(q1q2) - q0q3) + v2bz*(q0q1 + q2q3)) - my) + v2bx*q1*(fi_signed(v2bx*(q0q2 + q1q3) + v2bz*(fi_signed(fi_signed(fi(0.5, 0, 24, 24, fm)) - q1q1) - q2q2)) - mz), 1, 24, 16, fm);
end
function [q0,q1,q2,q3] = f16_Madgwick_update(q0_1,q1_1,q2_1,q3_1,qDot1_1,qDot2_1,qDot3_1,qDot4_1,s0,s1,s2,s3,beta,sampleTime)

fm = fimath('RoundingMethod', 'Floor', 'OverflowAction', 'Wrap', 'ProductMode', 'FullPrecision', 'MaxProductWordLength', 128, 'SumMode', 'FullPrecision', 'MaxSumWordLength', 128);

q0 = fi(q0_1, 1, 24, 22, fm);
q1 = fi(q1_1, 1, 24, 22, fm);
q2 = fi(q2_1, 1, 24, 22, fm);
q3 = fi(q3_1, 1, 24, 22, fm);
qDot1 = fi(qDot1_1, 1, 24, 17, fm);
qDot2 = fi(qDot2_1, 1, 24, 17, fm);
qDot3 = fi(qDot3_1, 1, 24, 17, fm);
qDot4 = fi(qDot4_1, 1, 24, 17, fm);

% Apply feedback step
qDot1 = fi(qDot1 - beta*s0, 1, 24, 17, fm);
qDot2 = fi(qDot2 - beta*s1, 1, 24, 17, fm);
qDot3 = fi(qDot3 - beta*s2, 1, 24, 17, fm);
qDot4 = fi(qDot4 - beta*s3, 1, 24, 17, fm);
% Integrate rate of change of quaternion to yield quaternion
q0 = fi(q0 + qDot1*sampleTime, 1, 24, 22, fm);
q1 = fi(q1 + qDot2*sampleTime, 1, 24, 22, fm);
q2 = fi(q2 + qDot3*sampleTime, 1, 24, 22, fm);
q3 = fi(q3 + qDot4*sampleTime, 1, 24, 22, fm);
end


function c = fi_div(a,b)
coder.inline( 'always' );
if isfi( a ) && isfi( b )
    a1 = fi( a, 'RoundMode', 'fix' );
    b1 = fi( b, 'RoundMode', 'fix' );
    c1 = divide( divideType( a1, b1 ), a1, b1 );
    c = fi( c1, numerictype( c1 ), fimath( a ) );
else
    c = a/b;
end
end


function ntype = divideType(a,b)
coder.inline( 'always' );
nt1 = numerictype( a );
nt2 = numerictype( b );
ntype = numerictype( nt1.Signed || nt2.Signed, nt1.WordLength + nt2.WordLength, (nt1.FractionLength - nt2.FractionLength + nt1.WordLength + nt2.WordLength - max( nt1.WordLength, nt2.WordLength )) );
end


function y = fi_signed(a)
coder.inline( 'always' );
if isfi( a ) && ~(issigned( a ))
    nt = numerictype( a );
    new_nt = numerictype( 1, nt.WordLength + 1, nt.FractionLength );
    y = fi( a, new_nt, fimath( a ) );
else
    y = a;
end
end


function y = fi_uminus(a)
coder.inline( 'always' );
if isfi( a )
    nt = numerictype( a );
    new_nt = numerictype( 1, nt.WordLength + 1, nt.FractionLength );
    y = -fi( a, new_nt, fimath( a ) );
else
    y = -a;
end
end
